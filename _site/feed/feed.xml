<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="pretty-atom-feed.xsl" type="text/xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <title>SpecStack</title>
  <subtitle>A free library of software specifications</subtitle>
  <link href="https://prestonp.github.com/feed/feed.xml" rel="self" />
  <link href="https://prestonp.github.com/specstack" />
  <updated>2025-04-06T11:18:40Z</updated>
  <id>https://prestonp.github.com/specstack</id>
  <author>
    <name>Preston Pham</name>
    <email>preston.p@fastmail.com</email>
  </author>
  <entry>
    <title>Two Layered Cache</title>
    <link href="https://prestonp.github.com/specs/quint/two_layered_cache/" />
    <updated>2025-04-06T11:18:40Z</updated>
    <id>https://prestonp.github.com/specs/quint/two_layered_cache/</id>
    <content type="html">&lt;pre&gt;&lt;code&gt;// -*- mode: Bluespec; -*-

 /** 
  * Quint specification for a two-layered cache system. The system consists of
  * two cache layers (L1 and L2) that store integer values. Clients can read and
  * write values to the cache. The specification verifies key properties like
  * read-after-write consistency and write-after-write consistency across the
  * cache layers.
  * 
  * Check with:
  *   quint verify &#92;
  *     two_layered_cache.qnt &#92;
  *     --invariant=readAfterWrite,writeAfterWrite &#92;
  *     --temporal=agreement &#92;
  *
  * Or with TLC using the `check_with_tlc.sh` script from this repo:
  *   sh check_with_tlc.sh &#92;
  *     --file ~/projects/quint/examples/classic/distributed/TwoLayeredCache/two_layered_cache.qnt &#92;
  *     --invariant readAfterWrite,writeAfterWrite &#92;
  *     --temporal agreement
  *
  * Preston Pham (@mt40), 2025
  */ 

module two_layered_cache {
    //**********************************************************
    // TYPE DEFINITIONS
    //**********************************************************

    type CacheLayer = str -&gt; int
    type ClientPID = int

    type HistoryEntry = Read(int) | Write(int)

    //**********************************************************
    // CONSTANTS
    //**********************************************************

    // We only consider 1 key in this spec but it is easy to
    // extend to multiple keys if needed
    pure val DefaultKey = &quot;default&quot;
    pure val DefaultExpireDuration = 3
    pure val ClientProcesses: Set[ClientPID] = 1.to(10)
    pure val MaxVal = 1000000
    pure val Expired = -99
    pure val NotFound = -98

    //**********************************************************
    // STATE MACHINE
    // State-dependent definitions and actions
    //**********************************************************

    var l1: CacheLayer
    var l2: CacheLayer
    var num: int

    // Global log of system events. Use to specify correctness
    // properties below.
    var history: List[HistoryEntry]

    //**********************************************************
    // FUNCTIONAL LAYER
    // Values and functions that are state-independent
    //**********************************************************

    pure def isWrite(entry: HistoryEntry): bool = {
        match entry {
            | Write(_) =&gt; true
            | _ =&gt; false
        }
    }

    pure def isRead(entry: HistoryEntry): bool = {
        match entry {
            | Read(_) =&gt; true
            | _ =&gt; false
        }
    }

    pure def value(entry: HistoryEntry): int = {
        match entry {
            | Read(v) =&gt; v
            | Write(v) =&gt; v
        }
    }

    pure def isNotEmpty(l: CacheLayer): bool = {
        l.keys().size() &gt; 0
    }

    //**********************************************************
    // HELPERS
    // Operators for convenience
    //**********************************************************

    action writeL1(v: int): bool = all {
        l1&#39; = l1.put(DefaultKey, v)
    }

    action writeL2(v: int): bool = all {
        l2&#39; = l2.put(DefaultKey, v)
    }

    //**********************************************************
    // ACTIONS
    //**********************************************************

    action writeCache(pid: ClientPID, v: int): bool = all {
        writeL1(v),
        writeL2(v),
        history&#39; = history.append(Write(v))
    }

    action handleNotFound(): bool = all {
        l1&#39; = l1,
        l2&#39; = l2,
        history&#39; = history.append(Read(NotFound))
    }

    action handleL1Found(): bool = {
        val value = l1.get(DefaultKey)
        all {
            l1&#39; = l1,
            l2&#39; = l2,
            history&#39; = history.append(Read(value))
        }
    }

    action handleL2Found(): bool = {
        val value = l2.get(DefaultKey)
        all {
            writeL1(value),
            l2&#39; = l2,
            history&#39; = history.append(Read(value))
        }
    }

    action handleFound(): bool = {
        if (isNotEmpty(l1)) {
            handleL1Found
        } else {
            handleL2Found
        }
    }

    // If val doesn&#39;t exist in L1, read from L2.
    // If val exists in L2, write back to L1 then return.
    // Otherwise, not found (false).
    action readCache(pid: ClientPID): bool = {
        if (isNotEmpty(l1) or isNotEmpty(l2)) {
            handleFound
        } else {
            handleNotFound
        }
    }

    action clientProc = all {
        nondet pid = ClientProcesses.oneOf()
        
        any {
            all {
                num&#39; = num + 1,
                writeCache(pid, num)
            },
            all {
                num&#39; = num,
                readCache(pid),
            }
        },
    }

    // Clear layer 1 data to simulate its
    // volatility. Because in practice, layer 1
    // usually uses memory for storage.
    action l1Expire = all {
        any {
            l1&#39; = l1,
            l1&#39; = Map()
        },
        l2&#39; = l2,
        num&#39; = num,
        history&#39; = history
    }

    action stutter = all {
        num&#39; = num,
        l1&#39; = l1,
        l2&#39; = l2,
        history&#39; = history,
    }

    action init = all {
        num&#39; = 0,
        l1&#39; = Map(),
        l2&#39; = Map(),
        history&#39; = [],
    }

    action step = all {
      // Limit the state space to enable exploration with TLC
      history.length() &lt; 15,
      any {
          clientProc,
          stutter,
          l1Expire
      }
    }

    //**********************************************************
    // CORRECTNESS
    // 1. Safety Properties / Invariants
    //**********************************************************

    // Read the latest write
    val readAfterWrite: bool = {
        val idx = history.indices()
        idx.forall(i =&gt; {
            idx.forall(j =&gt; {
                i &lt; j
                and history[i].isWrite()
                and history[j].isRead()
                implies history[i].value() &lt;= history[j].value()
            })
        })
    }

    // Later write must contain a greater value
    val writeAfterWrite: bool = {
        val idx = history.indices()
        idx.forall(i =&gt; {
            idx.forall(j =&gt; {
                i &lt; j
                and history[i].isWrite()
                and history[j].isWrite()
                implies history[i].value() &lt; history[j].value()
            })
        })
    }

    //**********************************************************
    // CORRECTNESS
    // 2. Liveness Properties / Temporal
    //**********************************************************

    // All layers contain the same latest written value
    temporal agreement: bool = eventually({
        val a = l1.get(DefaultKey)
        val b = l2.get(DefaultKey)
        a == b
    })

    //**********************************************************
    // QUICK TESTS
    //**********************************************************
    // run initAndStepTest = init.then(step)
}
&lt;/code&gt;&lt;/pre&gt;</content>
  </entry>
  <entry>
    <title>Test-And-Set Mutual Exclusion</title>
    <link href="https://prestonp.github.com/specs/tlaplus/test_and_set/" />
    <updated>2025-04-06T11:18:39Z</updated>
    <id>https://prestonp.github.com/specs/tlaplus/test_and_set/</id>
    <content type="html">&lt;pre&gt;&lt;code&gt;---------------------------- MODULE test_and_set ----------------------------

EXTENDS Integers
CONSTANTS Process
VARIABLES hasLock, lock, pc

At(p, loc)              == pc[p] = loc
GoTo(p, loc)            == pc&#39; = [pc EXCEPT ![p] = loc]
GoFromTo(p, loc1, loc2) == At(p, loc1) /&#92; GoTo(p, loc2)

TS(p, x, y) == (x&#39; = [x EXCEPT ![p] = y]) /&#92; (y&#39; = FALSE)

Wait(p) ==
    &#92;/ (hasLock[p] = FALSE /&#92; TS(p, hasLock, lock) /&#92; UNCHANGED&lt;&lt;pc&gt;&gt;)
    &#92;/ (hasLock[p] = TRUE /&#92; GoFromTo(p, &quot;wait&quot;, &quot;cs&quot;) /&#92; UNCHANGED&lt;&lt;hasLock, lock=&quot;&quot;&gt;&gt;)
CS(p) ==
    /&#92; GoFromTo(p, &quot;cs&quot;, &quot;reset&quot;)
    /&#92; UNCHANGED&lt;&lt;hasLock, lock=&quot;&quot;&gt;&gt;
Reset(p) ==
    /&#92; lock&#39; = TRUE
    /&#92; hasLock&#39; = [hasLock EXCEPT ![p] = FALSE]
    /&#92; GoFromTo(p, &quot;reset&quot;, &quot;wait&quot;)

Init ==
    /&#92; pc = [p &#92;in Process |-&gt; &quot;wait&quot;]
    /&#92; hasLock = [p &#92;in Process |-&gt; FALSE]
    /&#92; lock = TRUE
PNext(p)    == Wait(p) &#92;/ CS(p) &#92;/ Reset(p)
Next        == &#92;E p &#92;in Process: PNext(p)

NoConcurrentCS(i, j)    == (i # j) =&gt; (pc[i] # &quot;cs&quot;) &#92;/ (pc[j] # &quot;cs&quot;)
MutualExclusion         == &#92;A i, j &#92;in Process : []NoConcurrentCS(i, j)

vars            == &lt;&lt;hasLock, lock,=&quot;&quot; pc=&quot;&quot;&gt;&gt;
Fairness        == &#92;A p &#92;in Process : WF_vars(Wait(p) &#92;/ CS(p) &#92;/ Reset(p))
CSEventually    == (&#92;E i &#92;in Process : pc[i] &#92;in {&quot;wait&quot;}) ~&gt; (&#92;E j &#92;in Process : pc[j] = &quot;cs&quot;)
Progress        == Fairness =&gt; CSEventually

=============================================================================
&lt;/hasLock,&gt;&lt;/hasLock,&gt;&lt;/hasLock,&gt;&lt;/pc&gt;&lt;/code&gt;&lt;/pre&gt;</content>
  </entry>
  <entry>
    <title>Fischer&#39;s Mutual Exclusion</title>
    <link href="https://prestonp.github.com/specs/tlaplus/fischer/" />
    <updated>2025-04-06T11:18:39Z</updated>
    <id>https://prestonp.github.com/specs/tlaplus/fischer/</id>
    <content type="html">&lt;pre&gt;&lt;code&gt;------------------------------ MODULE fischer ------------------------------

EXTENDS Integers

CONSTANTS Process, Special
       
VARIABLES lock, pc

vars    == &lt;&lt;lock, pc=&quot;&quot;&gt;&gt;

At(p, loc) == pc[p] = loc
GoTo(p, loc) == pc&#39; = [pc EXCEPT ![p] = loc]
GoFromTo(p, loc1, loc2) == At(p, loc1) /&#92; GoTo(p, loc2)

NCS(p)      ==  /&#92; GoFromTo(p, &quot;ncs&quot;, &quot;a&quot;)
                /&#92; UNCHANGED&lt;&lt;lock&gt;&gt;
StmtA(p)    ==  /&#92; lock = Special
                /&#92; GoFromTo(p, &quot;a&quot;, &quot;b&quot;)
                /&#92; UNCHANGED&lt;&lt;lock&gt;&gt;
StmtB(p)    ==  /&#92; lock&#39; = p
                /&#92; GoFromTo(p, &quot;b&quot;, &quot;c&quot;)
StmtC(p)    ==  /&#92; IF lock # p THEN GoFromTo(p, &quot;c&quot;, &quot;a&quot;) ELSE GoFromTo(p, &quot;c&quot;, &quot;cs&quot;)
                /&#92; UNCHANGED&lt;&lt;lock&gt;&gt;
CS(p)       ==  /&#92; GoFromTo(p, &quot;cs&quot;, &quot;d&quot;)
                /&#92; UNCHANGED&lt;&lt;lock&gt;&gt;
StmtD(p)    ==  /&#92; GoFromTo(p, &quot;d&quot;, &quot;a&quot;)
                /&#92; lock&#39; = Special
                
PNext(p)    == NCS(p) &#92;/ StmtA(p) &#92;/ StmtB(p) &#92;/ CS(p) &#92;/ StmtD(p) &#92;/ StmtC(p)
Init        ==  /&#92; pc = [p &#92;in Process |-&gt; &quot;ncs&quot;]
                /&#92; lock = Special
Next        == &#92;E p &#92;in Process : PNext(p)


NoConcurrentCS(i, j) == (i # j) =&gt; (pc[i] # &quot;cs&quot;) &#92;/ (pc[j] # &quot;cs&quot;)
MutualExclusion == &#92;A i, j &#92;in Process : []NoConcurrentCS(i, j)


=============================================================================
&lt;/lock&gt;&lt;/lock&gt;&lt;/lock&gt;&lt;/lock&gt;&lt;/lock,&gt;&lt;/code&gt;&lt;/pre&gt;</content>
  </entry>
  <entry>
    <title>Message Queue</title>
    <link href="https://prestonp.github.com/specs/pluscal/message_queue/" />
    <updated>2025-04-06T11:18:39Z</updated>
    <id>https://prestonp.github.com/specs/pluscal/message_queue/</id>
    <content type="html">&lt;pre&gt;&lt;code&gt;---- MODULE message_queue ----
EXTENDS TLC, Integers, Sequences
CONSTANTS MaxQueueSize

(*--algorithm message_queue
variables
    queue = &lt;&lt;&gt;&gt;;

define
    BoundedQueue == Len(queue) &lt;= MaxQueueSize
end define;

procedure add_to_queue(val=&quot;&quot;) begin
    Add:
        await Len(queue) &lt; MaxQueueSize;
        queue := Append(queue, val);
        return;
end procedure;

    
process writer = &quot;writer&quot;
begin Write:
    while TRUE do
        call  add_to_queue(&quot;msg&quot;);
    end while;
end process;

process reader &#92;in {&quot;reader1&quot;, &quot;reader2&quot;}
variables
    current_msg = &quot;none&quot;;
begin Read:
    while TRUE do
        await queue # &lt;&lt;&gt;&gt;;
        current_msg := Head(queue);
        queue := Tail(queue);

        &#92;* simulate read failure
        either
            skip;
        or
            NotifyFailure:
                current_msg := &quot;none&quot;;
                call add_to_queue(self);
        end either;

    end while;
end process;

end algorithm; *)
&#92;* BEGIN TRANSLATION (chksum(pcal) = &quot;7cd74e9d&quot; /&#92; chksum(tla) = &quot;64391f26&quot;)
VARIABLES queue, pc, stack

(* define statement *)
BoundedQueue == Len(queue) &lt;= MaxQueueSize

VARIABLES val, current_msg

vars == &lt;&lt; queue, pc, stack, val, current_msg &gt;&gt;

ProcSet == {&quot;writer&quot;} &#92;cup ({&quot;reader1&quot;, &quot;reader2&quot;})

Init == (* Global variables *)
        /&#92; queue = &lt;&lt;&gt;&gt;
        (* Procedure add_to_queue *)
        /&#92; val = [ self &#92;in ProcSet |-&gt; &quot;&quot;]
        (* Process reader *)
        /&#92; current_msg = [self &#92;in {&quot;reader1&quot;, &quot;reader2&quot;} |-&gt; &quot;none&quot;]
        /&#92; stack = [self &#92;in ProcSet |-&gt; &lt;&lt; &gt;&gt;]
        /&#92; pc = [self &#92;in ProcSet |-&gt; CASE self = &quot;writer&quot; -&gt; &quot;Write&quot;
                                        [] self &#92;in {&quot;reader1&quot;, &quot;reader2&quot;} -&gt; &quot;Read&quot;]

Add(self) == /&#92; pc[self] = &quot;Add&quot;
             /&#92; Len(queue) &lt; MaxQueueSize
             /&#92; queue&#39; = Append(queue, val[self])
             /&#92; pc&#39; = [pc EXCEPT ![self] = Head(stack[self]).pc]
             /&#92; val&#39; = [val EXCEPT ![self] = Head(stack[self]).val]
             /&#92; stack&#39; = [stack EXCEPT ![self] = Tail(stack[self])]
             /&#92; UNCHANGED current_msg

add_to_queue(self) == Add(self)

Write == /&#92; pc[&quot;writer&quot;] = &quot;Write&quot;
         /&#92; /&#92; stack&#39; = [stack EXCEPT ![&quot;writer&quot;] = &lt;&lt; [ procedure |-&gt;  &quot;add_to_queue&quot;,
                                                         pc        |-&gt;  &quot;Write&quot;,
                                                         val       |-&gt;  val[&quot;writer&quot;] ] &gt;&gt;
                                                     &#92;o stack[&quot;writer&quot;]]
            /&#92; val&#39; = [val EXCEPT ![&quot;writer&quot;] = &quot;msg&quot;]
         /&#92; pc&#39; = [pc EXCEPT ![&quot;writer&quot;] = &quot;Add&quot;]
         /&#92; UNCHANGED &lt;&lt; queue, current_msg &gt;&gt;

writer == Write

Read(self) == /&#92; pc[self] = &quot;Read&quot;
              /&#92; queue # &lt;&lt;&gt;&gt;
              /&#92; current_msg&#39; = [current_msg EXCEPT ![self] = Head(queue)]
              /&#92; queue&#39; = Tail(queue)
              /&#92; &#92;/ /&#92; TRUE
                    /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;Read&quot;]
                 &#92;/ /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;NotifyFailure&quot;]
              /&#92; UNCHANGED &lt;&lt; stack, val &gt;&gt;

NotifyFailure(self) == /&#92; pc[self] = &quot;NotifyFailure&quot;
                       /&#92; current_msg&#39; = [current_msg EXCEPT ![self] = &quot;none&quot;]
                       /&#92; /&#92; stack&#39; = [stack EXCEPT ![self] = &lt;&lt; [ procedure |-&gt;  &quot;add_to_queue&quot;,
                                                                   pc        |-&gt;  &quot;Read&quot;,
                                                                   val       |-&gt;  val[self] ] &gt;&gt;
                                                               &#92;o stack[self]]
                          /&#92; val&#39; = [val EXCEPT ![self] = self]
                       /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;Add&quot;]
                       /&#92; queue&#39; = queue

reader(self) == Read(self) &#92;/ NotifyFailure(self)

Next == writer
           &#92;/ (&#92;E self &#92;in ProcSet: add_to_queue(self))
           &#92;/ (&#92;E self &#92;in {&quot;reader1&quot;, &quot;reader2&quot;}: reader(self))

Spec == Init /&#92; [][Next]_vars

&#92;* END TRANSLATION 
====
&lt;/code&gt;&lt;/pre&gt;</content>
  </entry>
  <entry>
    <title>Database Update Flow</title>
    <link href="https://prestonp.github.com/specs/pluscal/database_update_flow/" />
    <updated>2025-04-06T11:18:39Z</updated>
    <id>https://prestonp.github.com/specs/pluscal/database_update_flow/</id>
    <content type="html">&lt;pre&gt;&lt;code&gt;---- MODULE database_update_flow ----
EXTENDS TLC, Naturals, Integers, Sequences, FiniteSets

&#92;* model values
&#92;* ---------------
CONSTANTS NULL

&#92;* constants
&#92;* ---------------
MESSAGE_TYPE == {&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;}
MESSAGES_TO_SEND_COUNT == 3

&#92;* types
&#92;* ---------------
LogType == [diff: BOOLEAN, ctime: Nat, msg: MESSAGE_TYPE]
DataType == [mtime: Nat]

&#92;* utilities
SeqOf(set, count) == [1..count -&gt; set]

(*--algorithm database_update_flow
    variables
        &#92;* Pick from possible messages.
        &#92;* Simulate duplicate messages.
        all_messages &#92;in SeqOf(MESSAGE_TYPE, MESSAGES_TO_SEND_COUNT),
        &#92;* our database
        data = [mtime |-&gt; 0],
        &#92;* Use set to simulate out-of-order messages (e.g. retry)
        &#92;* For simplicity, we assume that kafka is partitioned by key already
        msg_queue = {},
        msg_to_send = all_messages,

        &#92;* ghost variables
        &#92;* ---------------
        produced_msg = {},
        consumed_msg = &lt;&lt;&gt;&gt;,
        &#92;* set of LogType
        compare_and_update_log = {};

    define
        &#92;* safety
        &#92;* ---------------
        &#92;* Older data can never overwrite newer data
        Integrity == &#92;A log &#92;in compare_and_update_log : ~log.diff &#92;/ (log.ctime &lt;= data.mtime)

        &#92;* liveness
        &#92;* ---------------
        &#92;* Assuming API call &amp; producing msg are atomic, when API is called, eventually C&amp;U will run
        Progress == &lt;&gt;(&#92;A msg &#92;in produced_msg : (&#92;E log &#92;in compare_and_update_log : log.msg = msg))
        &#92;* If Compare shows diff, data is eventually updated to newer
        Validity == &lt;&gt;(&#92;A log &#92;in compare_and_update_log : log.diff =&gt; (log.ctime &lt;= data.mtime))

    end define;

    procedure fail_by_budget(budget=0)
        variables
            internal_budget = budget;
        begin
        MayFail:
            either
                if internal_budget &gt; 0 then
                    internal_budget := internal_budget - 1;
                    goto MayFail;
                else
                    return;
                end if;
            or
                return;
            end either;
    end procedure;

    fair process producer = &quot;producer&quot;
    variables
        failure_budget = 3;
    begin
        ActionProducerPreCheck:
            if Len(msg_to_send) = 0 then
                goto ActionProducerDone;
            end if;
        
        ActionProducerMayFail:
            call fail_by_budget(failure_budget);

        ActionProducerLoop:
            msg_queue := msg_queue &#92;union {Head(msg_to_send)};
            produced_msg := produced_msg &#92;union {Head(msg_to_send)};
            msg_to_send := Tail(msg_to_send);
        
        ActionProducerNextStep:
            goto ActionProducerPreCheck;
        
        ActionProducerDone:
            skip;
    end process;

    fair process consumer = &quot;consumer&quot;
    variable
        clock = 1,
        cur_msg = &quot;no message&quot;,
        log = [diff |-&gt; FALSE, ctime |-&gt; 0, msg |-&gt; &quot;no message&quot;]; &#92;* LogType
    begin
        ActionConsumerWait:
            await Cardinality(msg_queue) &gt; 0;
        
        ActionConsumeMsgMayFail:
            call fail_by_budget(failure_budget);

        ActionConsumeMsg:
            cur_msg := CHOOSE m &#92;in msg_queue: TRUE;
            log := [diff |-&gt; FALSE, ctime |-&gt; clock, msg |-&gt; cur_msg];
            clock := clock + 1;
        
        ActionCompareMayFail:
            call fail_by_budget(failure_budget);

        ActionCompare:
            either
                log.diff := FALSE;
            or
                log.diff := TRUE;
            end either;
            clock := clock + 1;
        
        ActionUpdateMayFail:
            call fail_by_budget(failure_budget);
        
        ActionUpdate:
            if log.diff then
                data.mtime := clock;
            end if;
            clock := clock + 1;
        
        ActionMsgACKMayFail:
            call fail_by_budget(failure_budget);
        
        ActionMsgACK:
            consumed_msg := Append(consumed_msg, cur_msg);
            msg_queue := msg_queue &#92; {cur_msg};
            clock := clock + 1;
            compare_and_update_log := compare_and_update_log &#92;union {log};
        
        ActionConsumerNextStep:
            goto ActionConsumerWait;
    end process; 

    end algorithm; *)
&#92;* BEGIN TRANSLATION (chksum(pcal) = &quot;5ffe163b&quot; /&#92; chksum(tla) = &quot;789a10f4&quot;)
VARIABLES all_messages, data, msg_queue, msg_to_send, produced_msg, 
          consumed_msg, compare_and_update_log, pc, stack

(* define statement *)
Integrity == &#92;A log &#92;in compare_and_update_log : ~log.diff &#92;/ (log.ctime &lt;= data.mtime)




Progress == &lt;&gt;(&#92;A msg &#92;in produced_msg : (&#92;E log &#92;in compare_and_update_log : log.msg = msg))

Validity == &lt;&gt;(&#92;A log &#92;in compare_and_update_log : log.diff =&gt; (log.ctime &lt;= data.mtime))

VARIABLES budget, internal_budget, failure_budget, clock, cur_msg, log

vars == &lt;&lt; all_messages, data, msg_queue, msg_to_send, produced_msg, 
           consumed_msg, compare_and_update_log, pc, stack, budget, 
           internal_budget, failure_budget, clock, cur_msg, log &gt;&gt;

ProcSet == {&quot;producer&quot;} &#92;cup {&quot;consumer&quot;}

Init == (* Global variables *)
        /&#92; all_messages &#92;in SeqOf(MESSAGE_TYPE, MESSAGES_TO_SEND_COUNT)
        /&#92; data = [mtime |-&gt; 0]
        /&#92; msg_queue = {}
        /&#92; msg_to_send = all_messages
        /&#92; produced_msg = {}
        /&#92; consumed_msg = &lt;&lt;&gt;&gt;
        /&#92; compare_and_update_log = {}
        (* Procedure fail_by_budget *)
        /&#92; budget = [ self &#92;in ProcSet |-&gt; 0]
        /&#92; internal_budget = [ self &#92;in ProcSet |-&gt; budget[self]]
        (* Process producer *)
        /&#92; failure_budget = 3
        (* Process consumer *)
        /&#92; clock = 1
        /&#92; cur_msg = &quot;no message&quot;
        /&#92; log = [diff |-&gt; FALSE, ctime |-&gt; 0, msg |-&gt; &quot;no message&quot;]
        /&#92; stack = [self &#92;in ProcSet |-&gt; &lt;&lt; &gt;&gt;]
        /&#92; pc = [self &#92;in ProcSet |-&gt; CASE self = &quot;producer&quot; -&gt; &quot;ActionProducerPreCheck&quot;
                                        [] self = &quot;consumer&quot; -&gt; &quot;ActionConsumerWait&quot;]

MayFail(self) == /&#92; pc[self] = &quot;MayFail&quot;
                 /&#92; &#92;/ /&#92; IF internal_budget[self] &gt; 0
                             THEN /&#92; internal_budget&#39; = [internal_budget EXCEPT ![self] = internal_budget[self] - 1]
                                  /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;MayFail&quot;]
                                  /&#92; UNCHANGED &lt;&lt; stack, budget &gt;&gt;
                             ELSE /&#92; pc&#39; = [pc EXCEPT ![self] = Head(stack[self]).pc]
                                  /&#92; internal_budget&#39; = [internal_budget EXCEPT ![self] = Head(stack[self]).internal_budget]
                                  /&#92; budget&#39; = [budget EXCEPT ![self] = Head(stack[self]).budget]
                                  /&#92; stack&#39; = [stack EXCEPT ![self] = Tail(stack[self])]
                    &#92;/ /&#92; pc&#39; = [pc EXCEPT ![self] = Head(stack[self]).pc]
                       /&#92; internal_budget&#39; = [internal_budget EXCEPT ![self] = Head(stack[self]).internal_budget]
                       /&#92; budget&#39; = [budget EXCEPT ![self] = Head(stack[self]).budget]
                       /&#92; stack&#39; = [stack EXCEPT ![self] = Tail(stack[self])]
                 /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, msg_to_send, 
                                 produced_msg, consumed_msg, 
                                 compare_and_update_log, failure_budget, clock, 
                                 cur_msg, log &gt;&gt;

fail_by_budget(self) == MayFail(self)

ActionProducerPreCheck == /&#92; pc[&quot;producer&quot;] = &quot;ActionProducerPreCheck&quot;
                          /&#92; IF Len(msg_to_send) = 0
                                THEN /&#92; pc&#39; = [pc EXCEPT ![&quot;producer&quot;] = &quot;ActionProducerDone&quot;]
                                ELSE /&#92; pc&#39; = [pc EXCEPT ![&quot;producer&quot;] = &quot;ActionProducerMayFail&quot;]
                          /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, 
                                          msg_to_send, produced_msg, 
                                          consumed_msg, compare_and_update_log, 
                                          stack, budget, internal_budget, 
                                          failure_budget, clock, cur_msg, log &gt;&gt;

ActionProducerMayFail == /&#92; pc[&quot;producer&quot;] = &quot;ActionProducerMayFail&quot;
                         /&#92; /&#92; budget&#39; = [budget EXCEPT ![&quot;producer&quot;] = failure_budget]
                            /&#92; stack&#39; = [stack EXCEPT ![&quot;producer&quot;] = &lt;&lt; [ procedure |-&gt;  &quot;fail_by_budget&quot;,
                                                                           pc        |-&gt;  &quot;ActionProducerLoop&quot;,
                                                                           internal_budget |-&gt;  internal_budget[&quot;producer&quot;],
                                                                           budget    |-&gt;  budget[&quot;producer&quot;] ] &gt;&gt;
                                                                       &#92;o stack[&quot;producer&quot;]]
                         /&#92; internal_budget&#39; = [internal_budget EXCEPT ![&quot;producer&quot;] = budget&#39;[&quot;producer&quot;]]
                         /&#92; pc&#39; = [pc EXCEPT ![&quot;producer&quot;] = &quot;MayFail&quot;]
                         /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, 
                                         msg_to_send, produced_msg, 
                                         consumed_msg, compare_and_update_log, 
                                         failure_budget, clock, cur_msg, log &gt;&gt;

ActionProducerLoop == /&#92; pc[&quot;producer&quot;] = &quot;ActionProducerLoop&quot;
                      /&#92; msg_queue&#39; = (msg_queue &#92;union {Head(msg_to_send)})
                      /&#92; produced_msg&#39; = (produced_msg &#92;union {Head(msg_to_send)})
                      /&#92; msg_to_send&#39; = Tail(msg_to_send)
                      /&#92; pc&#39; = [pc EXCEPT ![&quot;producer&quot;] = &quot;ActionProducerNextStep&quot;]
                      /&#92; UNCHANGED &lt;&lt; all_messages, data, consumed_msg, 
                                      compare_and_update_log, stack, budget, 
                                      internal_budget, failure_budget, clock, 
                                      cur_msg, log &gt;&gt;

ActionProducerNextStep == /&#92; pc[&quot;producer&quot;] = &quot;ActionProducerNextStep&quot;
                          /&#92; pc&#39; = [pc EXCEPT ![&quot;producer&quot;] = &quot;ActionProducerPreCheck&quot;]
                          /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, 
                                          msg_to_send, produced_msg, 
                                          consumed_msg, compare_and_update_log, 
                                          stack, budget, internal_budget, 
                                          failure_budget, clock, cur_msg, log &gt;&gt;

ActionProducerDone == /&#92; pc[&quot;producer&quot;] = &quot;ActionProducerDone&quot;
                      /&#92; TRUE
                      /&#92; pc&#39; = [pc EXCEPT ![&quot;producer&quot;] = &quot;Done&quot;]
                      /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, 
                                      msg_to_send, produced_msg, consumed_msg, 
                                      compare_and_update_log, stack, budget, 
                                      internal_budget, failure_budget, clock, 
                                      cur_msg, log &gt;&gt;

producer == ActionProducerPreCheck &#92;/ ActionProducerMayFail
               &#92;/ ActionProducerLoop &#92;/ ActionProducerNextStep
               &#92;/ ActionProducerDone

ActionConsumerWait == /&#92; pc[&quot;consumer&quot;] = &quot;ActionConsumerWait&quot;
                      /&#92; Cardinality(msg_queue) &gt; 0
                      /&#92; pc&#39; = [pc EXCEPT ![&quot;consumer&quot;] = &quot;ActionConsumeMsgMayFail&quot;]
                      /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, 
                                      msg_to_send, produced_msg, consumed_msg, 
                                      compare_and_update_log, stack, budget, 
                                      internal_budget, failure_budget, clock, 
                                      cur_msg, log &gt;&gt;

ActionConsumeMsgMayFail == /&#92; pc[&quot;consumer&quot;] = &quot;ActionConsumeMsgMayFail&quot;
                           /&#92; /&#92; budget&#39; = [budget EXCEPT ![&quot;consumer&quot;] = failure_budget]
                              /&#92; stack&#39; = [stack EXCEPT ![&quot;consumer&quot;] = &lt;&lt; [ procedure |-&gt;  &quot;fail_by_budget&quot;,
                                                                             pc        |-&gt;  &quot;ActionConsumeMsg&quot;,
                                                                             internal_budget |-&gt;  internal_budget[&quot;consumer&quot;],
                                                                             budget    |-&gt;  budget[&quot;consumer&quot;] ] &gt;&gt;
                                                                         &#92;o stack[&quot;consumer&quot;]]
                           /&#92; internal_budget&#39; = [internal_budget EXCEPT ![&quot;consumer&quot;] = budget&#39;[&quot;consumer&quot;]]
                           /&#92; pc&#39; = [pc EXCEPT ![&quot;consumer&quot;] = &quot;MayFail&quot;]
                           /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, 
                                           msg_to_send, produced_msg, 
                                           consumed_msg, 
                                           compare_and_update_log, 
                                           failure_budget, clock, cur_msg, log &gt;&gt;

ActionConsumeMsg == /&#92; pc[&quot;consumer&quot;] = &quot;ActionConsumeMsg&quot;
                    /&#92; cur_msg&#39; = (CHOOSE m &#92;in msg_queue: TRUE)
                    /&#92; log&#39; = [diff |-&gt; FALSE, ctime |-&gt; clock, msg |-&gt; cur_msg&#39;]
                    /&#92; clock&#39; = clock + 1
                    /&#92; pc&#39; = [pc EXCEPT ![&quot;consumer&quot;] = &quot;ActionCompareMayFail&quot;]
                    /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, msg_to_send, 
                                    produced_msg, consumed_msg, 
                                    compare_and_update_log, stack, budget, 
                                    internal_budget, failure_budget &gt;&gt;

ActionCompareMayFail == /&#92; pc[&quot;consumer&quot;] = &quot;ActionCompareMayFail&quot;
                        /&#92; /&#92; budget&#39; = [budget EXCEPT ![&quot;consumer&quot;] = failure_budget]
                           /&#92; stack&#39; = [stack EXCEPT ![&quot;consumer&quot;] = &lt;&lt; [ procedure |-&gt;  &quot;fail_by_budget&quot;,
                                                                          pc        |-&gt;  &quot;ActionCompare&quot;,
                                                                          internal_budget |-&gt;  internal_budget[&quot;consumer&quot;],
                                                                          budget    |-&gt;  budget[&quot;consumer&quot;] ] &gt;&gt;
                                                                      &#92;o stack[&quot;consumer&quot;]]
                        /&#92; internal_budget&#39; = [internal_budget EXCEPT ![&quot;consumer&quot;] = budget&#39;[&quot;consumer&quot;]]
                        /&#92; pc&#39; = [pc EXCEPT ![&quot;consumer&quot;] = &quot;MayFail&quot;]
                        /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, 
                                        msg_to_send, produced_msg, 
                                        consumed_msg, compare_and_update_log, 
                                        failure_budget, clock, cur_msg, log &gt;&gt;

ActionCompare == /&#92; pc[&quot;consumer&quot;] = &quot;ActionCompare&quot;
                 /&#92; &#92;/ /&#92; log&#39; = [log EXCEPT !.diff = FALSE]
                    &#92;/ /&#92; log&#39; = [log EXCEPT !.diff = TRUE]
                 /&#92; clock&#39; = clock + 1
                 /&#92; pc&#39; = [pc EXCEPT ![&quot;consumer&quot;] = &quot;ActionUpdateMayFail&quot;]
                 /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, msg_to_send, 
                                 produced_msg, consumed_msg, 
                                 compare_and_update_log, stack, budget, 
                                 internal_budget, failure_budget, cur_msg &gt;&gt;

ActionUpdateMayFail == /&#92; pc[&quot;consumer&quot;] = &quot;ActionUpdateMayFail&quot;
                       /&#92; /&#92; budget&#39; = [budget EXCEPT ![&quot;consumer&quot;] = failure_budget]
                          /&#92; stack&#39; = [stack EXCEPT ![&quot;consumer&quot;] = &lt;&lt; [ procedure |-&gt;  &quot;fail_by_budget&quot;,
                                                                         pc        |-&gt;  &quot;ActionUpdate&quot;,
                                                                         internal_budget |-&gt;  internal_budget[&quot;consumer&quot;],
                                                                         budget    |-&gt;  budget[&quot;consumer&quot;] ] &gt;&gt;
                                                                     &#92;o stack[&quot;consumer&quot;]]
                       /&#92; internal_budget&#39; = [internal_budget EXCEPT ![&quot;consumer&quot;] = budget&#39;[&quot;consumer&quot;]]
                       /&#92; pc&#39; = [pc EXCEPT ![&quot;consumer&quot;] = &quot;MayFail&quot;]
                       /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, 
                                       msg_to_send, produced_msg, consumed_msg, 
                                       compare_and_update_log, failure_budget, 
                                       clock, cur_msg, log &gt;&gt;

ActionUpdate == /&#92; pc[&quot;consumer&quot;] = &quot;ActionUpdate&quot;
                /&#92; IF log.diff
                      THEN /&#92; data&#39; = [data EXCEPT !.mtime = clock]
                      ELSE /&#92; TRUE
                           /&#92; data&#39; = data
                /&#92; clock&#39; = clock + 1
                /&#92; pc&#39; = [pc EXCEPT ![&quot;consumer&quot;] = &quot;ActionMsgACKMayFail&quot;]
                /&#92; UNCHANGED &lt;&lt; all_messages, msg_queue, msg_to_send, 
                                produced_msg, consumed_msg, 
                                compare_and_update_log, stack, budget, 
                                internal_budget, failure_budget, cur_msg, log &gt;&gt;

ActionMsgACKMayFail == /&#92; pc[&quot;consumer&quot;] = &quot;ActionMsgACKMayFail&quot;
                       /&#92; /&#92; budget&#39; = [budget EXCEPT ![&quot;consumer&quot;] = failure_budget]
                          /&#92; stack&#39; = [stack EXCEPT ![&quot;consumer&quot;] = &lt;&lt; [ procedure |-&gt;  &quot;fail_by_budget&quot;,
                                                                         pc        |-&gt;  &quot;ActionMsgACK&quot;,
                                                                         internal_budget |-&gt;  internal_budget[&quot;consumer&quot;],
                                                                         budget    |-&gt;  budget[&quot;consumer&quot;] ] &gt;&gt;
                                                                     &#92;o stack[&quot;consumer&quot;]]
                       /&#92; internal_budget&#39; = [internal_budget EXCEPT ![&quot;consumer&quot;] = budget&#39;[&quot;consumer&quot;]]
                       /&#92; pc&#39; = [pc EXCEPT ![&quot;consumer&quot;] = &quot;MayFail&quot;]
                       /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, 
                                       msg_to_send, produced_msg, consumed_msg, 
                                       compare_and_update_log, failure_budget, 
                                       clock, cur_msg, log &gt;&gt;

ActionMsgACK == /&#92; pc[&quot;consumer&quot;] = &quot;ActionMsgACK&quot;
                /&#92; consumed_msg&#39; = Append(consumed_msg, cur_msg)
                /&#92; msg_queue&#39; = msg_queue &#92; {cur_msg}
                /&#92; clock&#39; = clock + 1
                /&#92; compare_and_update_log&#39; = (compare_and_update_log &#92;union {log})
                /&#92; pc&#39; = [pc EXCEPT ![&quot;consumer&quot;] = &quot;ActionConsumerNextStep&quot;]
                /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_to_send, produced_msg, 
                                stack, budget, internal_budget, failure_budget, 
                                cur_msg, log &gt;&gt;

ActionConsumerNextStep == /&#92; pc[&quot;consumer&quot;] = &quot;ActionConsumerNextStep&quot;
                          /&#92; pc&#39; = [pc EXCEPT ![&quot;consumer&quot;] = &quot;ActionConsumerWait&quot;]
                          /&#92; UNCHANGED &lt;&lt; all_messages, data, msg_queue, 
                                          msg_to_send, produced_msg, 
                                          consumed_msg, compare_and_update_log, 
                                          stack, budget, internal_budget, 
                                          failure_budget, clock, cur_msg, log &gt;&gt;

consumer == ActionConsumerWait &#92;/ ActionConsumeMsgMayFail
               &#92;/ ActionConsumeMsg &#92;/ ActionCompareMayFail &#92;/ ActionCompare
               &#92;/ ActionUpdateMayFail &#92;/ ActionUpdate
               &#92;/ ActionMsgACKMayFail &#92;/ ActionMsgACK
               &#92;/ ActionConsumerNextStep

(* Allow infinite stuttering to prevent deadlock on termination. *)
Terminating == /&#92; &#92;A self &#92;in ProcSet: pc[self] = &quot;Done&quot;
               /&#92; UNCHANGED vars

Next == producer &#92;/ consumer
           &#92;/ (&#92;E self &#92;in ProcSet: fail_by_budget(self))
           &#92;/ Terminating

Spec == /&#92; Init /&#92; [][Next]_vars
        /&#92; WF_vars(producer) /&#92; WF_vars(fail_by_budget(&quot;producer&quot;))
        /&#92; WF_vars(consumer) /&#92; WF_vars(fail_by_budget(&quot;consumer&quot;))

Termination == &lt;&gt;(&#92;A self &#92;in ProcSet: pc[self] = &quot;Done&quot;)

&#92;* END TRANSLATION 
====
&lt;/code&gt;&lt;/pre&gt;</content>
  </entry>
  <entry>
    <title>Left Pad</title>
    <link href="https://prestonp.github.com/specs/pluscal/leftpad/" />
    <updated>2025-04-06T11:18:39Z</updated>
    <id>https://prestonp.github.com/specs/pluscal/leftpad/</id>
    <content type="html">&lt;pre&gt;&lt;code&gt;---- MODULE leftpad ----
EXTENDS TLC, Sequences, FiniteSets, Integers

SeqOf(char, count) == [1..count -&gt; {char}]

(*--algorithm leftpad

variables
    CHARS = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;},
    input_len &#92;in 1..10,
    input_str &#92;in SeqOf(&quot;x&quot;, input_len),
    pad_len &#92;in 0..5,
    pad_char &#92;in CHARS,
    output_str = &lt;&lt;&gt;&gt;;

begin
    if pad_len &lt;= Len(input_str) then
        output_str := input_str;
    else
        output_str := [x &#92;in 1..(pad_len - Len(input_str)) |-&gt; pad_char];
        output_str := output_str &#92;o input_str;
    end if;

    assert (
        pad_len &gt; Len(input_str)
        /&#92; (&#92;A i &#92;in 1..(pad_len - Len(input_str)) : output_str[i] = pad_char)
    ) &#92;/ (
        pad_len &lt;= Len(input_str)
        /&#92; output_str = input_str
    );
end algorithm; *)
&#92;* BEGIN TRANSLATION (chksum(pcal) = &quot;bc9d2d85&quot; /&#92; chksum(tla) = &quot;db8e8bf3&quot;)
VARIABLES CHARS, input_len, input_str, pad_len, pad_char, output_str, pc

vars == &lt;&lt; CHARS, input_len, input_str, pad_len, pad_char, output_str, pc &gt;&gt;

Init == (* Global variables *)
        /&#92; CHARS = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
        /&#92; input_len &#92;in 1..10
        /&#92; input_str &#92;in SeqOf(&quot;x&quot;, input_len)
        /&#92; pad_len &#92;in 0..5
        /&#92; pad_char &#92;in CHARS
        /&#92; output_str = &lt;&lt;&gt;&gt;
        /&#92; pc = &quot;Lbl_1&quot;

Lbl_1 == /&#92; pc = &quot;Lbl_1&quot;
         /&#92; IF pad_len &lt;= Len(input_str)
               THEN /&#92; output_str&#39; = input_str
                    /&#92; pc&#39; = &quot;Lbl_3&quot;
               ELSE /&#92; output_str&#39; = [x &#92;in 1..(pad_len - Len(input_str)) |-&gt; pad_char]
                    /&#92; pc&#39; = &quot;Lbl_2&quot;
         /&#92; UNCHANGED &lt;&lt; CHARS, input_len, input_str, pad_len, pad_char &gt;&gt;

Lbl_2 == /&#92; pc = &quot;Lbl_2&quot;
         /&#92; output_str&#39; = output_str &#92;o input_str
         /&#92; pc&#39; = &quot;Lbl_3&quot;
         /&#92; UNCHANGED &lt;&lt; CHARS, input_len, input_str, pad_len, pad_char &gt;&gt;

Lbl_3 == /&#92; pc = &quot;Lbl_3&quot;
         /&#92; Assert(       (
                       pad_len &gt; Len(input_str)
                       /&#92; (&#92;A i &#92;in 1..(pad_len - Len(input_str)) : output_str[i] = pad_char)
                   ) &#92;/ (
                       pad_len &lt;= Len(input_str)
                       /&#92; output_str = input_str
                   ), &quot;Failure of assertion at line 24, column 5.&quot;)
         /&#92; pc&#39; = &quot;Done&quot;
         /&#92; UNCHANGED &lt;&lt; CHARS, input_len, input_str, pad_len, pad_char, 
                         output_str &gt;&gt;

(* Allow infinite stuttering to prevent deadlock on termination. *)
Terminating == pc = &quot;Done&quot; /&#92; UNCHANGED vars

Next == Lbl_1 &#92;/ Lbl_2 &#92;/ Lbl_3
           &#92;/ Terminating

Spec == Init /&#92; [][Next]_vars

Termination == &lt;&gt;(pc = &quot;Done&quot;)

&#92;* END TRANSLATION 
====
&lt;/code&gt;&lt;/pre&gt;</content>
  </entry>
  <entry>
    <title>Dekker</title>
    <link href="https://prestonp.github.com/specs/pluscal/dekker/" />
    <updated>2025-04-06T11:18:39Z</updated>
    <id>https://prestonp.github.com/specs/pluscal/dekker/</id>
    <content type="html">&lt;pre&gt;&lt;code&gt;---- MODULE dekker ----
EXTENDS TLC, Integers, FiniteSets, Sequences
Servers == 1..2
(*--algorithm dekker

variables
    &#92;*Servers = &lt;&lt;1, 2&gt;&gt;, &#92;* only works with 2 servers
    flag = [s &#92;in Servers |-&gt; FALSE], &#92;* indicate the server that is running
    next_server &#92;in Servers;

define
    &#92;* safety
    MutualExclusion == &#92;A s1, s2 &#92;in Servers : s1 # s2 =&gt; ~(pc[s1] = &quot;CS&quot; /&#92; pc[s2] = &quot;CS&quot;)

    &#92;* liveness
    Progress == &#92;E s &#92;in {1} : &lt;&gt;(pc[s] = &quot;CS&quot;)
    &#92;* deadlock is already checked by default by TLC
end define;

procedure server()
    begin
    P1: flag[self] := TRUE;

    &#92;* scenario that violates Progress:
    &#92;*     1. crash process reaches P2_1_1 and then crashes
    &#92;*     2. fair process reaches P2_1
    &#92;*     3. fair process check P2_1 if condition and fails, go back to while loop of P2
    &#92;*     4. fair process repeats step 2 &amp; 3 forever
    P2:
        while &#92;E s &#92;in (Servers &#92; {self}) : flag[s] do
            P2_1:
                if next_server # self then
                    P2_1_1: flag[self] := FALSE;
                    P2_1_2: await next_server = self;
                    P2_1_3: flag[self] := TRUE;
                end if;
        end while;

    &#92;* simulate Critical Section
    CS: skip;

    P3: next_server := 3 - next_server;
    P4: flag[self] := FALSE;
    P5: goto P1;
end procedure;

fair process fair_server &#92;in {1}
begin
    Fair:
        call server();
end process;

process crashable_server &#92;in {2}
begin
    Crashable:
        call server();

end process;

end algorithm; *)
&#92;* BEGIN TRANSLATION (chksum(pcal) = &quot;21bbb53&quot; /&#92; chksum(tla) = &quot;d967e409&quot;)
VARIABLES flag, next_server, pc, stack

(* define statement *)
MutualExclusion == &#92;A s1, s2 &#92;in Servers : s1 # s2 =&gt; ~(pc[s1] = &quot;CS&quot; /&#92; pc[s2] = &quot;CS&quot;)


Progress == &#92;E s &#92;in {1} : &lt;&gt;(pc[s] = &quot;CS&quot;)


vars == &lt;&lt; flag, next_server, pc, stack &gt;&gt;

ProcSet == ({1}) &#92;cup ({2})

Init == (* Global variables *)
        /&#92; flag = [s &#92;in Servers |-&gt; FALSE]
        /&#92; next_server &#92;in Servers
        /&#92; stack = [self &#92;in ProcSet |-&gt; &lt;&lt; &gt;&gt;]
        /&#92; pc = [self &#92;in ProcSet |-&gt; CASE self &#92;in {1} -&gt; &quot;Fair&quot;
                                        [] self &#92;in {2} -&gt; &quot;Crashable&quot;]

P1(self) == /&#92; pc[self] = &quot;P1&quot;
            /&#92; flag&#39; = [flag EXCEPT ![self] = TRUE]
            /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P2&quot;]
            /&#92; UNCHANGED &lt;&lt; next_server, stack &gt;&gt;

P2(self) == /&#92; pc[self] = &quot;P2&quot;
            /&#92; IF &#92;E s &#92;in (Servers &#92; {self}) : flag[s]
                  THEN /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P2_1&quot;]
                  ELSE /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;CS&quot;]
            /&#92; UNCHANGED &lt;&lt; flag, next_server, stack &gt;&gt;

P2_1(self) == /&#92; pc[self] = &quot;P2_1&quot;
              /&#92; IF next_server # self
                    THEN /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P2_1_1&quot;]
                    ELSE /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P2&quot;]
              /&#92; UNCHANGED &lt;&lt; flag, next_server, stack &gt;&gt;

P2_1_1(self) == /&#92; pc[self] = &quot;P2_1_1&quot;
                /&#92; flag&#39; = [flag EXCEPT ![self] = FALSE]
                /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P2_1_2&quot;]
                /&#92; UNCHANGED &lt;&lt; next_server, stack &gt;&gt;

P2_1_2(self) == /&#92; pc[self] = &quot;P2_1_2&quot;
                /&#92; next_server = self
                /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P2_1_3&quot;]
                /&#92; UNCHANGED &lt;&lt; flag, next_server, stack &gt;&gt;

P2_1_3(self) == /&#92; pc[self] = &quot;P2_1_3&quot;
                /&#92; flag&#39; = [flag EXCEPT ![self] = TRUE]
                /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P2&quot;]
                /&#92; UNCHANGED &lt;&lt; next_server, stack &gt;&gt;

CS(self) == /&#92; pc[self] = &quot;CS&quot;
            /&#92; TRUE
            /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P3&quot;]
            /&#92; UNCHANGED &lt;&lt; flag, next_server, stack &gt;&gt;

P3(self) == /&#92; pc[self] = &quot;P3&quot;
            /&#92; next_server&#39; = 3 - next_server
            /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P4&quot;]
            /&#92; UNCHANGED &lt;&lt; flag, stack &gt;&gt;

P4(self) == /&#92; pc[self] = &quot;P4&quot;
            /&#92; flag&#39; = [flag EXCEPT ![self] = FALSE]
            /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P5&quot;]
            /&#92; UNCHANGED &lt;&lt; next_server, stack &gt;&gt;

P5(self) == /&#92; pc[self] = &quot;P5&quot;
            /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P1&quot;]
            /&#92; UNCHANGED &lt;&lt; flag, next_server, stack &gt;&gt;

server(self) == P1(self) &#92;/ P2(self) &#92;/ P2_1(self) &#92;/ P2_1_1(self)
                   &#92;/ P2_1_2(self) &#92;/ P2_1_3(self) &#92;/ CS(self) &#92;/ P3(self)
                   &#92;/ P4(self) &#92;/ P5(self)

Fair(self) == /&#92; pc[self] = &quot;Fair&quot;
              /&#92; stack&#39; = [stack EXCEPT ![self] = &lt;&lt; [ procedure |-&gt;  &quot;server&quot;,
                                                       pc        |-&gt;  &quot;Done&quot; ] &gt;&gt;
                                                   &#92;o stack[self]]
              /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P1&quot;]
              /&#92; UNCHANGED &lt;&lt; flag, next_server &gt;&gt;

fair_server(self) == Fair(self)

Crashable(self) == /&#92; pc[self] = &quot;Crashable&quot;
                   /&#92; stack&#39; = [stack EXCEPT ![self] = &lt;&lt; [ procedure |-&gt;  &quot;server&quot;,
                                                            pc        |-&gt;  &quot;Done&quot; ] &gt;&gt;
                                                        &#92;o stack[self]]
                   /&#92; pc&#39; = [pc EXCEPT ![self] = &quot;P1&quot;]
                   /&#92; UNCHANGED &lt;&lt; flag, next_server &gt;&gt;

crashable_server(self) == Crashable(self)

(* Allow infinite stuttering to prevent deadlock on termination. *)
Terminating == /&#92; &#92;A self &#92;in ProcSet: pc[self] = &quot;Done&quot;
               /&#92; UNCHANGED vars

Next == (&#92;E self &#92;in ProcSet: server(self))
           &#92;/ (&#92;E self &#92;in {1}: fair_server(self))
           &#92;/ (&#92;E self &#92;in {2}: crashable_server(self))
           &#92;/ Terminating

Spec == /&#92; Init /&#92; [][Next]_vars
        /&#92; &#92;A self &#92;in {1} : WF_vars(fair_server(self)) /&#92; WF_vars(server(self))

Termination == &lt;&gt;(&#92;A self &#92;in ProcSet: pc[self] = &quot;Done&quot;)

&#92;* END TRANSLATION 
====
&lt;/code&gt;&lt;/pre&gt;</content>
  </entry>
</feed>